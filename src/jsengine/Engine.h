/*
 * Copyright (C) 2005-2010 Erik Nilsson, software on versionstudio point com
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#ifndef guard_engine_h
#define guard_engine_h

#include <ace/synch.h>

#include <jsapi.h>
#include <jsdate.h>

#include "../server/httpresponse.h"
#include "../server/httprequest.h"

/**
* Engine.
* Script engine based on SpiderMonkey (JavaScript).
*/
class Engine
{
public:
	/**
	 * Default constructor.
	 * @return instance
	 */
	Engine() : m_runtime(NULL) {
		
	}

	static const int IO_BUFFER_SIZE;

	/**
	 * Initialize the engine. Run before using the instance
	 * in order to make the runtime ready.
	 * @return true if the engine was initialized successfully.
	 */
	bool init();

	/**
	 * Clean up the engine. Run when the instance won't be used anymore
	 * in order to destroy the created contexes and runtime.
	 */
	void cleanup();

	/**
	 * Execute the given through the script engine.
	 * The engine takes care of finding a suitable context, parsing the file 
	 * as well as handling any response to the client.
	 * @param file the open handle to the file to execute
	 * @param httpRequest the http request
	 * @param httpResponse the http response
	 * @return true if the file was handled by the engine
	 */
	bool executeFile(FILE *file,HttpServerRequest &httpRequest,HttpServerResponse &httpResponse);

	/**
	 * Execute the given through the script engine in the given context.
	 * The engine takes care of parsing the file as well as handling any response to the client.
	 * @param file the open handle to the file to execute
	 * @param httpRequest the http request
	 * @param httpResponse the http response
	 * @return true if the file was handled by the engine
	 */
	bool executeFile(FILE *file,JSContext *cx,JSObject *obj);

	/**
	 * Throw an error due to error when parsing a script.
	 * @param cx the context throwing the error
	 */
	void throwParseError(JSContext *cx);

	/**
	 * Throw an error due to invalid usage of a custom class or function.
	 * @param cx the context throwing the error
	 * @param argv the arguments sent to the function handler
	 * @return JSBool
	 */
	static JSBool throwUsageError(JSContext *cx,jsval *argv);

private:
	/**
	* Initialize all custom javascript classes.
	* @param cx the context in which to initialize the class
	* @param obj the global object for the context
	* @return true if all classes was initializes
	*/
	bool initCustomClasses(JSContext *cx,JSObject *obj);
	
	/**
	 * Create all predefined object instances, such as "request", "response" etc.
	 * @param cx the context in which to create the object instances
	 * @param obj the global object for the context
	 * @param httpRequest the http request executing the script, required for some predefined objects
	 */
	void createPredefinedObjects(JSContext *cx,JSObject *obj,HttpServerRequest &httpRequest);

	/**
	* Clean up all predefined object instances.
	* @param cx the context in which the object instances exist
	* @param obj the global object for the context
	*/
	void cleanupPredefinedObjects(JSContext *cx,JSObject *obj);

	/**
	 * Execute the given directive.
	 * The given directive string will be parsed and executed.
	 * @param directive the directive string to be parsed
	 * @param httpRequest the http request
	 * @return output out parameter for any script output generated by the execution of the directive
	 * @return true if directive was parsed and executed
	 */
	bool executeDirective(std::string directive,HttpServerRequest &httpRequest,
		std::string &output);

	/**
	 * Parses the file content into a script valid to be executed in the js engine.
	 * Everything wrapped between "<?" and "?>" is considered to be scripts, while
	 * all other text will be wrapped in a call to response.print() in order to included in the output.
	 * @param file the open handle to the file to parse
	 * @param httpRequest the http request
	 * @param script the out parameter for the parsed script
	 * @return true if the file was successfully parsed as a script
	 */
	bool parseFile(FILE *file,HttpServerRequest &httpRequest,std::string &script);

	/**
	* Parse the given directive into the name of the directive and the given attributes.
	* @param directive the directive to parse
	* @param name the out parameter for the matching directive name
	* @param attributes the out parameter for the given attributes
	* @return true if the directive was parsed successfully
	*/
	bool parseDirective(const std::string &directive,std::string &name,
		std::map<std::string,std::string> &attributes);

	/**
	 * Make the given string into a script response by wrapping
	 * it into a response.println script statement.
	 * @param msg the response message
	 */
	std::string makeResponse(const std::string &msg);

	/**
	 * Callback function used as the error reporter for a context.
	 * @param cx the context in which the error happened
	 * @param msg the error message
	 * @param errorReport an error report record containing additional details about the error
	 */
	static void reportError(JSContext *cx,const char *msg,JSErrorReport *errorReport);

	ACE_Mutex m_mutex;

	JSRuntime *m_runtime;

	std::stack<JSContext*> m_contexts;
};

#endif
