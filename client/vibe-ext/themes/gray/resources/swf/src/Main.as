/* * Copyright (C) 2005-2010 Erik Nilsson, software on versionstudio point com * * This program is free software: you can redistribute it and/or modify * it under the terms of the GNU General Public License as published by * the Free Software Foundation, either version 3 of the License, or * (at your option) any later version. * * This program is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the * GNU General Public License for more details. * * You should have received a copy of the GNU General Public License * along with this program.  If not, see <http://www.gnu.org/licenses/>. */ package{	import flash.display.LoaderInfo;	import flash.display.MovieClip;		import flash.events.*;	import flash.external.*;	import flash.net.*;	import flash.text.TextField;	import flash.utils.Timer;		import vibe.events.*;	import vibe.sound.*;	import vibe.util.*;    public class Main extends MovieClip 	{		private var _soundPlayer:SoundPlayer = null;		private var _currentUrl:String = "";		private var _currentTitle:String = "";		private var _currentBitRate:int = 0;		private var _bufferTime:int = 1000;		private var _callbackObject = "vibe.Application.getHeaderPanel()";				private const EXTERNAL_CALLBACK_NEXTCLICK:String = "flashPlayerNextClick";		private const EXTERNAL_CALLBACK_PLAYCLICK:String = "flashPlayerPlayClick";		private const EXTERNAL_CALLBACK_PREVCLICK:String = "flashPlayerPrevClick";		private const EXTERNAL_CALLBACK_TRACKPAUSE:String = "flashPlayerTrackPause";		private const EXTERNAL_CALLBACK_TRACKRESUME:String = "flashPlayerTrackResume";		private const EXTERNAL_CALLBACK_TRACKSTOP:String = "flashPlayerTrackStop";		private const EXTERNAL_CALLBACK_TRACKSTART:String = "flashPlayerTrackStart";		private const EXTERNAL_METHOD_PLAYTRACK = "playTrack";				private const LANGUAGE_BUFFERING:String = "Buffering";		private const LANGUAGE_FAILED_TO_LOAD_AUDIO:String = "Failed to load audio";		private const LANGUAGE_NO_AUDIO_PLAYING:String = "No audio playing";		private const LANGUAGE_UNKNOWN:String = "Unknown";		private const PARAMETER_BUFFERTIME:String = "bufferTime";		private const PARAMETER_CALLBACKOBJECT:String = "callbackObject";		public function Main()		{			var parameters:Object = LoaderInfo(this.root.loaderInfo).parameters;									if ( parameters[PARAMETER_BUFFERTIME]!=null ) {				_bufferTime = parameters[PARAMETER_BUFFERTIME];			}						if ( parameters[PARAMETER_CALLBACKOBJECT]!=null ) {				_callbackObject = parameters[PARAMETER_CALLBACKOBJECT];			}						_soundPlayer = new SoundPlayer();						this.positionField.selectable = false;			this.informationField.selectable = false;						_nextBtn.useHandCursor = false;			_pauseBtn.useHandCursor = false;			_playBtn.useHandCursor = false;			_prevBtn.useHandCursor = false;						// sound player event listeners			_soundPlayer.addEventListener(SoundPlayerEvent.ID3,onSoundPlayerId3);			_soundPlayer.addEventListener(SoundPlayerEvent.ERROR,onSoundPlayerError);			_soundPlayer.addEventListener(SoundPlayerEvent.PAUSE,onSoundPlayerPause);						_soundPlayer.addEventListener(SoundPlayerEvent.PROGRESS,onSoundPlayerProgress);			_soundPlayer.addEventListener(SoundPlayerEvent.RESUME,onSoundPlayerResume);			_soundPlayer.addEventListener(SoundPlayerEvent.START,onSoundPlayerStart);			_soundPlayer.addEventListener(SoundPlayerEvent.STOP,onSoundPlayerStop);						// slider event listeners			_volumeSlider.addEventListener(SliderEvent.CHANGE,onVolumeSliderChange);			_timeSlider.addEventListener(SliderEvent.DRAGEND,onTimeSliderDragEnd);									// button event listeners			_nextBtn.addEventListener(MouseEvent.CLICK,onNextBtnClick);			_pauseBtn.addEventListener(MouseEvent.CLICK,onPauseBtnClick);			_playBtn.addEventListener(MouseEvent.CLICK,onPlayBtnClick);			_prevBtn.addEventListener(MouseEvent.CLICK,onPrevBtnClick);						// external callbacks			ExternalInterface.addCallback(EXTERNAL_METHOD_PLAYTRACK,onExternalPlayTrack);						updateControls();			updateDisplay();					}				public function updateDisplay():void		{			var displayTitle:String = "";			var displayBitRate:Number = _currentBitRate;			var displayLengthSeconds:Number = 0;			var displayPositionSeconds:Number = 0;						if ( _soundPlayer.playing )			{				var soundLength:Number = _soundPlayer.sound.length;				var soundPosition:Number = _soundPlayer.soundChannel.position;								displayPositionSeconds = Math.floor(soundPosition/1000);								if ( _currentTitle.length>0 ) {					displayTitle = _currentTitle;				}				else				{					var pos:int = _currentUrl.lastIndexOf("/");					if ( pos!=-1 ) {						displayTitle = unescape(_currentUrl.substr(pos+1));					}					else {						displayTitle = unescape(_currentUrl);					}				}												// check if song is still buffering				if ( _soundPlayer.sound.isBuffering ) {					displayTitle = LANGUAGE_BUFFERING + " - " + displayTitle;				}								// check if song has loaded completely				if ( _soundPlayer.sound.bytesLoaded==_soundPlayer.sound.bytesTotal ) {					displayLengthSeconds = Math.floor(soundLength/1000);				}								// adjust time slider handle position				if ( !_timeSlider.dragging && soundLength>0 && soundPosition>0 ) 				{					var position:Number = soundPosition/soundLength;					if ( _soundPlayer.sound.bytesLoaded!=_soundPlayer.sound.bytesTotal ) {						position = position * (_soundPlayer.sound.bytesLoaded/_soundPlayer.sound.bytesTotal);					}					_timeSlider.value = position;				}								// adjust time slider mask				_timeSlider.adjustTimeBarMask(_soundPlayer.sound.bytesLoaded/_soundPlayer.sound.bytesTotal);			}			else			{				displayTitle = LANGUAGE_NO_AUDIO_PLAYING;				displayBitRate = 0;								// reset time slider				_timeSlider.value = 0;				_timeSlider.adjustTimeBarMask(0);			}						this.informationField.htmlText = displayTitle;						if ( displayLengthSeconds>0 ) {				this.informationField.htmlText += " <font color=\"#c1c1c1\">(" + FormatUtil.formatDisplayTime(displayLengthSeconds) + ")</font>";			}						if ( displayBitRate>0 ) {				this.informationField.htmlText += " <font color=\"#c1c1c1\">" + displayBitRate + " kbps</font>";			}						this.positionField.text = FormatUtil.formatDisplayTime(displayPositionSeconds);		}				private function updateControls():void		{			if ( _soundPlayer.playing )			{				_timeSlider.dragEnabled = true;								if ( _soundPlayer.paused ) {					_playBtn.visible = true;					_pauseBtn.visible = false;				}				else {					_playBtn.visible = false;					_pauseBtn.visible = true;				}			}			else 			{				_timeSlider.dragEnabled = false;								_playBtn.visible = true;				_pauseBtn.visible = false;			}		}				private function playTrack(url:String,title:String,bitRate:int):void		{			_currentUrl = url;			_currentTitle = title;			_currentBitRate = bitRate;			_soundPlayer.startSound(url,_bufferTime);						updateControls();		}				private function onExternalPlayTrack(url:String,title:String,bitRate:int):void		{			playTrack(url,title,bitRate);		}				private function onNextBtnClick(event:MouseEvent):void		{			String(ExternalInterface.call(_callbackObject + "." + EXTERNAL_CALLBACK_NEXTCLICK));		}				private function onPauseBtnClick(event:MouseEvent):void		{			if ( _soundPlayer.playing && !_soundPlayer.paused ) {				_soundPlayer.pauseSound();				updateControls();			}		}				private function onPlayBtnClick(event:MouseEvent):void		{			if ( _soundPlayer.playing && _soundPlayer.paused ) {				_soundPlayer.resumeSound();				updateControls();			}			else 			{				String(ExternalInterface.call(_callbackObject + "." + EXTERNAL_CALLBACK_PLAYCLICK));			}		}				private function onPrevBtnClick(event:MouseEvent):void		{			String(ExternalInterface.call(_callbackObject + "." + EXTERNAL_CALLBACK_PREVCLICK));		}				private function onSoundPlayerId3(event:SoundPlayerEvent):void		{			if ( _currentTitle.length>0 ) {				return;			}			var artist:String = _soundPlayer.sound.id3.artist;			var songName:String = _soundPlayer.sound.id3.songName;					if ( artist.length==0 ) {				artist = LANGUAGE_UNKNOWN;			}			if ( songName.length==0 ) {				songName = LANGUAGE_UNKNOWN;			}						_currentTitle = artist + " - " + songName;		}						private function onSoundPlayerError(event:SoundPlayerEvent):void		{						var errorMessage:String = "";						// TODO: provide detailed error message			errorMessage = LANGUAGE_FAILED_TO_LOAD_AUDIO;						updateDisplay();			updateControls();			this.informationField.text = errorMessage;		}				private function onSoundPlayerPause(event:SoundPlayerEvent):void		{			String(ExternalInterface.call(_callbackObject + "." + EXTERNAL_CALLBACK_TRACKPAUSE));		}				private function onSoundPlayerProgress(event:SoundPlayerEvent):void		{			updateDisplay();		}				private function onSoundPlayerResume(event:SoundPlayerEvent):void		{			String(ExternalInterface.call(_callbackObject + "." + EXTERNAL_CALLBACK_TRACKRESUME));		}						private function onSoundPlayerStart(event:SoundPlayerEvent):void		{			String(ExternalInterface.call(_callbackObject + "." + EXTERNAL_CALLBACK_TRACKSTART));		}				private function onSoundPlayerStop(event:SoundPlayerEvent):void		{			var completed:Boolean = false;						if ( event.position==-1 ) {				completed = true;			}						String(ExternalInterface.call(_callbackObject + "." + EXTERNAL_CALLBACK_TRACKSTOP,completed));					updateControls();			updateDisplay();					}				private function onVolumeSliderChange(event:Event):void		{			_soundPlayer.volume = _volumeSlider.value;		}				private function onTimeSliderDragEnd(event:Event):void		{			if ( _soundPlayer.playing ) 			{				var loadedValue = _soundPlayer.sound.bytesLoaded/_soundPlayer.sound.bytesTotal;				if ( _timeSlider.value>loadedValue ) {					_timeSlider.value = loadedValue;				}								var position = _timeSlider.value*_soundPlayer.sound.length*					(_soundPlayer.sound.bytesTotal/_soundPlayer.sound.bytesLoaded);								_soundPlayer.resumePosition(position);								updateControls();			}		}			}}